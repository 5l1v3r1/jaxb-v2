/**
 * Grammar for schema component designator
 */
options {
  STATIC=false;
  ERROR_REPORTING=true;
  // DEBUG_TOKEN_MANAGER=true;
}

PARSER_BEGIN(SCDParser)
package com.sun.xml.xsom.impl.scd;

import java.util.*;
import java.io.*;
import com.sun.xml.xsom.impl.UName;
import javax.xml.namespace.*;

public class SCDParser {
  private NamespaceContext nsc;
  public SCDParser(String text,NamespaceContext nsc) {
    this(new StringReader(text));
    this.nsc = nsc;
  }
  private String trim(String s) {
    return s.substring(1,s.length()-1);
  }
  private String resolvePrefix(String prefix) throws ParseException {
    try {
      String r=nsc.getNamespaceURI(prefix);
      // grrr!!
      if(prefix.equals(""))
        return r;
      if(!r.equals(""))
        return r;
    } catch( IllegalArgumentException e ) {
      ; // report an error
    }
    throw new ParseException("Unbound prefix: "+prefix);
  }
}

PARSER_END(SCDParser)


SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

TOKEN :
{
  // TODO: fix NCName
  < NCNAME: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* > |
  < NUMBER: "[" (["0"-"9"])+ "]"> |
  < FACETNAME: "ordered" | "bounded" | "numeric" | "cardinality" | "whiteSpace" | "minInclusive" | "maxInclusive" | "minExclusive" | "maxExclusive" | "totalDigits" | "fractionDigits" | "length" | "minLength" | "maxLength" | "pattern" | "enumeration" >
} // "[^:]+"

UName QName() : { Token p,l=null; }
{
  p=<NCNAME> ( ":" l=<NCNAME> ) ?
  {
    if(l==null)
      return new UName(resolvePrefix(""),p.image);
    else
      return new UName(resolvePrefix(p.image),l.image);
  }
}

String Prefix() : { Token p="";}
{
  (p=<NCNAME>)? {return resolvePrefix(p.image);}
}


List RelativeSchemaComponentPath() :
{
  List steps = new ArrayList();
  Step s;
}
{
  (// make it absolute
    "/"  {steps.add(new Step.Any(Axis.ROOT));}
  | "//" {steps.add(new Step.Any(Axis.DESCENDANTS));}
  )?
  s=Step() {steps.add(s);}
  (
    (
      "/"
    | "//" {steps.add(new Step.Any(Axis.DESCENDANTS));}
    )
    s=Step() {steps.add(s);}
  )*
  { return steps; }
}

Step Step() :
{
  Step s; String p; Token n;
}
{(
  ("attribute::"|"@")     s=NameOrWildcard(Axis.ATTRIBUTE)
| ("element::")?          s=NameOrWildcard(Axis.ELEMENT) (Predicate(s))?
| "substitutionGroup::"   s=NameOrWildcard(Axis.SUBSTITUTION_GROUP)
| ("type::"|"~")          s=NameOrWildcardOrAnonymous(Axis.TYPE_DEFINITION)
| "baseType::"            s=NameOrWildcard(Axis.BASETYPE)
| "primitiveType::"       s=NameOrWildcard(Axis.PRIMITIVE_TYPE)
| "itemType::"            s=NameOrWildcardOrAnonymous(Axis.ITEM_TYPE)
| "memberType::"          s=NameOrWildcardOrAnonymous(Axis.MEMBER_TYPE) (Predicate(s))?
| "scope::"               s=NameOrWildcardOrAnonymous(Axis.SCOPE)
| "attributeGroup::"      s=NameOrWildcard(Axis.ATTRIBUTE_GROUP)
| "group::"               s=NameOrWildcard(Axis.MODEL_GROUP_DECL)
| "identityContraint::"   s=NameOrWildcard(Axis.IDENTITY_CONSTRAINT)
| "key::"                 s=NameOrWildcard(Axis.REFERENCED_KEY)
| "notation::"            s=NameOrWildcard(Axis.NOTATION)
// TODO: support "annotation::*"
| "model::sequence"       {s=new Step.Any(Axis.MODELGROUP_SEQUENCE);} (Predicate(s))?
| "model::choice"         {s=new Step.Any(Axis.MODELGROUP_CHOICE);} (Predicate(s))?
| "model::all"            {s=new Step.Any(Axis.MODELGROUP_ALL);} (Predicate(s))?
| "model::*"              {s=new Step.Any(Axis.MODELGROUP_ANY);} (Predicate(s))?
| "any::*"                {s=new Step.Any(Axis.WILDCARD);} (Predicate(s))?
| "anyAttribute::*"       {s=new Step.Any(Axis.ATTRIBUTE_WILDCARD);}
| "facet::*"              {s=new Step.Any(Axis.FACET);}
| "facet::" n=<FACETNAME> {s=new Step.Facet(Axis.FACET,n.image);}
| "component::*"          {s=new Step.Any(Axis.DESCENDANTS);} // this is not in BNF but in prose
| "x-schema::" p=Prefix() {s=new Step.Schema(Axis.X_SCHEMA,p);} // this is non-standard
| "x-schema::*"           {s=new Step.Any(Axis.X_SCHEMA);} // this is non-standard
) {return s;}}

Step NameOrWildcard(Axis a) : {UName un;}
{
  un=QName() { return new Step.Named(a,un); }
| "*"        { return new Step.Any(a); }
}

Step NameOrWildcardOrAnonymous(Axis a) : {UName un;}
{
  un=QName() { return new Step.Named(a,un); }
| "*"        { return new Step.Any(a); }
| "0"	       { return new Step.AnonymousType(a); }
}

int Predicate(Step s) :
{
  Token t;
}
{
  t=<NUMBER> { return s.predicate=Integer.parseInt(trim(t.image)); }
}